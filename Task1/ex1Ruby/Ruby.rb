# Функция, проверяющая, покрыты ли все кооперативы связью
def check_coverage(n, x, towers)
    # Проверяем корректность входных данных
    return false if n <= 0 || x < 0 || towers.length != n
  
    # Создаём массив covered размером n, заполненный false (означает отсутствие покрытия)
    covered = Array.new(n, false)
  
    # Проходим по всем вышкам
    towers.chars.each_with_index do |tower, i|
      if tower == '1'  # Если вышка работает, она покрывает кооперативы вокруг
        # Определяем границы зоны покрытия
        start = [0, i - x].max  # Левая граница не может быть меньше 0
        end_idx = [n - 1, i + x].min  # Правая граница не может выходить за пределы массива
  
        # Заполняем массив covered в зоне покрытия вышки
        (start..end_idx).each { |j| covered[j] = true }
      end
    end
  
    # Проверяем, покрыты ли все кооперативы (если есть хотя бы один false, возвращаем false)
    covered.all?
  end
  
  # Главная функция программы
  def main
    begin
      # Ввод данных
      print "Введите количество вышек: "
      n = Integer(gets.chomp)  # Читаем количество вышек, преобразуем в число
  
      print "Введите показатель покрытия: "
      x = Integer(gets.chomp)  # Читаем показатель покрытия, преобразуем в число
  
      print "Введите строку состояния вышек: "
      towers = gets.chomp  # Читаем строку состояний вышек
  
      # Проверяем корректность введённых данных:
      # - towers должна содержать только '0' и '1'
      # - её длина должна быть равна n
      if n <= 0 || x < 0 || towers.length != n || towers.match(/[^01]/)
        puts "No"  # Если данные некорректные, выводим "No"
        return
      end
  
      # Выводим результат: "Yes", если все кооперативы покрыты, иначе "No"
      puts check_coverage(n, x, towers) ? "Yes" : "No"
  
    rescue ArgumentError
      # Если при вводе произошла ошибка (например, введены нечисловые данные), выводим "No"
      puts "No"
    end
  end
  
  # Запускаем программу
  main
  